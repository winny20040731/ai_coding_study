# 用 AI 编程：从 Vibe 到 Spec 的实战入门

## 1. 2025：Vibe Coding 元年

2025 年，编程世界出现了一个重要转折点：**Vibe Coding 让不会写代码的人也能做软件，2025 年被视为它的元年。**

- 2025 被视为 Vibe Coding 元年：用自然语言让 AI 写代码，不再纠结具体语法。
- Karpathy 提出 “vibe coding”：沉浸在想法里，把“我想要什么”说清楚，AI 负责实现。 
- 柯林斯词典将 “Vibe Coding” 评为年度词汇，标记它成为新主流编程方式之一。 
- 创业公司中约 25% 表示 95% 代码由 AI 生成，小团队能完成过去大公司级别的产品。 
- 越来越多非程序员（设计、产品、运营、文科生）开始“指挥 AI 做软件”，角色从 Coder 走向 Commander。 

---

## 2. 2025 AI 编程工具全景图

2025 年，“用自然语言描述需求、AI 生成代码”已经由一整套工具生态支撑。可以先选一个顺手的，逐步深入。 

- AI 编程工具主要分为五大类：对话式 AI、AI 代码编辑器、IDE 插件、网页版 AI 编程、命令行工具。 
- 对话式 AI（ChatGPT、Claude 等）：零基础首选，直接用中文聊天要代码，适合体验“用中文写代码”。 
- AI 代码编辑器（Cursor、Windsurf、Trae 等）：能理解整个项目，适合认真学习和实践 AI 编程的人。 
- IDE 插件（Copilot、Cline 等）：在 VS Code/JetBrains 里加 AI 助手，适合已有开发习惯的程序员。 
- 网页版 AI 编程（豆包 AI 编程、Bolt.new 等）：零安装，一键生成可运行网站，适合快速看结果。 
- 命令行工具（Claude Code、Aider 等）：在终端里与 AI 协作，效率高，适合有一定基础的开发者。 
- 选工具原则：不必全学，从一个免费顺手的开始，用熟了再换或升级。 

---

## 3. Vibe Coding vs Spec Coding

Vibe 更像“边走边看、边聊边做”；Spec 更像“先画好蓝图，再按图施工”。两者不是对立，而是互补的两种模式。

### 3.1 什么是 Vibe Coding？

- **Vibe Coding = 用对话迭代，把模糊想法做成真实产品的开发方式。**
- 适合：一开始需求不清晰、想边做边探索的项目，而不是先写一份很长的详细规范。
- 典型过程：模糊想法 → AI 给出初版 → 实际体验后提反馈 → 多轮微调 → 需求和产品一起变清晰。
- 核心要素：需求探索、对话累积（聊天记录即文档）、快速迭代、良好的上下文管理。
- 与 Spec Coding 区别：Vibe 在对话中动态澄清需求，Spec 在一开始就写好清晰规范再执行。
- 适用场景：验证产品想法、做个人小工具、边学边做的练手项目、创意和实验性强的应用。

### 3.2 什么是 Spec Coding？

- **Spec Coding = 需求明确时，先写清规范，再让 AI 严格按规范执行的开发方式。**  
- 适用场景：需求已经比较清晰、多人协作、中大型或质量要求高的项目。  
- 常见触发点：AI 开始忘需求、功能打架、多人参与，或项目复杂到对话难以承载。  
- 演化路径：先用 Vibe 探索 → 需求变清晰 → 整理对话成文档 → 进入按规范执行的 Spec 阶段。  
- 核心文档：  
  - 需求文档：做什么 / 不做什么。  
  - 设计文档：技术选型、架构与关键决策。  
  - 任务清单：按批次拆解功能，安排节奏。  
- 优势：可追溯、有利协作、质量可控、上下文稳定（不再全靠聊天记录）。  
- 推荐策略：用 Vibe 探索新功能，用 Spec 沉淀和维护稳定功能，两种方式混合使用。  

---

## 4. 上下文与提示词：从“想清楚”到“说清楚”

AI 编程的关键不在“一句神奇咒语”，而在于提供高质量上下文：告诉 AI 你是谁、在做什么、这一刻想干嘛。  

### 4.1 Context 管理技巧

- Context = AI 能看到的所有背景信息，质量直接决定回答效果。  
- 模型记忆有限，内容过多会“忘记前文”，因此要刻意筛选和总结信息。  

三层 Context 建议：  
- 即时层：当前任务说明＋具体报错或示例，重要信息放在开头或结尾。  
- 中期层：项目目标、当前进度、已知问题、技术栈与关键决策，定期写成小结给 AI 看。  
- 长期层：项目历史档案，如最初需求、版本记录、重要修改原因等，必要时贴出摘要。  

实用操作与信号：  
- 新任务时用几行话重置背景：“项目是什么＋做到哪＋这次想干嘛”。  
- 每 10–15 轮对话做一次“已完成 / 下一步”的总结，发给 AI。  
- 不同主题开不同对话：功能开发、Bug 修复、架构讨论分开聊。  
- 当对话太长、目标多次变更、AI 频繁误解时，考虑开新对话并重述关键信息。  

### 4.2 Context is King：上下文为王

- 公式：**AI 输出质量 = 上下文质量 × AI 能力**。  
- 上下文三要素：  
  - 背景信息：项目是什么、给谁用。  
  - 约束条件：要 / 不要什么、技术栈和风格限制。  
  - 期望结果：想要什么形式和粒度的输出。  

三层上下文模型：  
- 项目上下文：项目类型、技术栈、目标用户、目标与风格。  
- 任务上下文：当前要做什么、输入输出、格式与约束。  
- 个人上下文：你的水平、学习目标、解释偏好（要不要注释、要不要类比）。  

- 好 / 差提示词对比：只说“帮我做个待办清单”，AI 会乱猜技术；补全三层上下文后，结果更贴近真实需求。  
- 上下文窗口：AI 有有限“记忆桌面”，不同对话不会共享，需要用项目规则或系统提示词保存关键信息。  

### 4.3 什么是提示词工程？

- **提示词工程本质：不是“提问的艺术”，而是“提供上下文的艺术”。**  
- 趋势：从 Prompt Engineering 转向 Context Engineering，重点从“怎么问”转向“先把哪些信息告诉 AI”。  
- 类比：AI 像极聪明但刚入职的实习生，结果好坏取决于有无清晰项目背景与要求。  
- 核心原则：信息越清晰完整，输出越符合预期；不靠“魔法词”，靠明确的背景、约束和目标。  
- 与传统编程：  
  - 传统编程：用代码与机器对话，语法极精确，容错率低。  
  - 提示词工程：用自然语言与 AI 对话，允许一定模糊，但强依赖表达和上下文质量。  
- 与产品思考的关系：  
  - “灵魂三问”“用户画像”“减法思维”本质上都是在为 AI 准备更好的上下文。  
  - 前面是“想清楚”，提示词工程是“说清楚”。  

### 4.4 R.G.C. 框架：Role → Goal → Constraints

- **R.G.C. 框架：先定角色，再说目标，再划约束，适合快速高效提问。**  

三要素速记：  
- Role：让 AI 扮演谁，如“对初学者友好的编程导师 / React 开发者 / 严格代码审查员”。  
- Goal：要完成什么任务，用“动词 + 名词”，如“重构这段代码”“解释回调函数”。  
- Constraints：限制条件，如技术栈、输出格式、长度控制、“不要做什么”等。  

典型用法与升级判断：  
- 场景：代码重构、解释概念、生成测试数据、做代码审查等，都可以用一段 R.G.C. 模板说明清楚。  
- 适用：项目已熟悉、任务不复杂、只是想快速验证想法时，用 R.G.C. 就够了。  
- 如常出现技术栈不对、功能深浅错位、风格不合、格式混乱，说明缺少更多背景，需要升级到更完整的 S.C.A.F.F. 框架。  

---

## 5. 边界与兜底：Vibe Coding 不是什么

Vibe Coding 很强，但不是“全能魔法棒”。理解它的边界，学会兜底策略，才能在关键场景不翻车。

### 5.1 Vibe Coding 的局限性

- AI 生成代码并不完美：约 45% 代码存在安全隐患，过度依赖可能让 bug 增加，主观感觉提速，客观却可能变慢。 
- “70% 问题”：AI 擅长样板代码、标准功能和原型，那 30% 的系统架构、复杂业务、边界、安全与性能仍高度依赖人类。 
- “80% 墙”：项目做到约 80% 后，每加一个功能都会变难，因为代码体量变大、上下文超出模型记忆、全局一致性变差。 
- 五大弱项场景：复杂业务逻辑、大型项目（多文件）、安全关键功能、性能优化、复杂/跨文件 bug 调试。 
- 正确心态：Vibe Coding 像翻译软件，足够应付“旅游级”开发（个人工具、简单网站），要跨过 70% 和 80% 仍需系统的编程与工程能力。 

### 5.2 兜底策略：当 AI 真的搞不定

- 先认清边界：AI 擅长标准化代码、文档、模式识别、快速原型；不擅长复杂环境配置、实时调试、强业务逻辑、安全与实时数据操作。  
- 警示信号：给足上下文仍错；连续多轮“看着对但跑不通”；涉及本地环境或难以文字描述的视觉问题；改了多轮仍没解决。  

三种兜底方案：  
- 换一个 AI 工具：重新用简洁语言描述需求和现状，暂时不要带上旧错误代码。  
- 用搜索引擎找现成方案：先查 Stack Overflow / GitHub / 官方文档，再让 AI 帮“翻译＋适配”到自己的项目中。  
- 用 AI 学原理，自己实现：让 AI 解释概念和给伪代码，你按思路手写，再请 AI 帮你查错优化。  

混合开发模式与求助节点：  
- 模式一：AI 生骨架（文件结构、函数签名、注释），你写核心逻辑。  
- 模式二：AI 出初版，你做代码审查，简单问题让它改，复杂问题自己改。  
- 模式三：AI 负责 CRUD、测试模板、UI 骨架和文档，你负责业务逻辑、关键算法、交互细节与架构决策。  
- 何时找人帮忙：卡住超过 2 小时无进展、问题影响数据安全或系统稳定、涉及你完全陌生的安全/性能/DevOps/架构领域。  
- 可选渠道：Stack Overflow、GitHub Issues、技术社区/Discord 或付费顾问，提问时说明目标、问题、已尝试方法、最小复现代码和环境信息。  